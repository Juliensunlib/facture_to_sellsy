// Importation des modules n√©cessaires
import dotenv from 'dotenv';
import Airtable from 'airtable';
import { generateInvoice } from './sellsy.js';
import { formatDate, calculateDueDate } from './utils.js';

// Chargement des variables d'environnement
dotenv.config();

// Configuration d'Airtable
const base = new Airtable({
  apiKey: process.env.AIRTABLE_API_KEY
}).base(process.env.AIRTABLE_BASE_ID);

// Tables Airtable
const abonnementsTable = base('Abonnements');
const serviceTable = base('service_sellsy');

/**
 * Fonction principale qui s'ex√©cute quotidiennement
 */
async function main() {
  console.log('üöÄ D√©marrage de la v√©rification des factures √† g√©n√©rer...');

  try {
    // 1. R√©cup√©rer tous les abonnements actifs
    const abonnements = await getActiveSubscriptions();
    console.log(`üìã ${abonnements.length} abonnements actifs trouv√©s`);

    // 2. Pour chaque abonnement, v√©rifier si une facture doit √™tre g√©n√©r√©e aujourd'hui
    let invoicesGenerated = 0;

    for (const abonnement of abonnements) {
      const invoiceNeeded = checkIfInvoiceNeeded(abonnement);
      
      if (!invoiceNeeded) continue;

      // 3. Si oui, g√©n√©rer la facture dans Sellsy
      const services = await getServicesForSubscription(abonnement);
      
      if (services.length === 0) {
        console.warn(`‚ö†Ô∏è Aucun service trouv√© pour l'abonnement ID ${abonnement.id}`);
        continue;
      }

      await generateInvoicesForServices(abonnement, services);
      invoicesGenerated++;
    }

    console.log(`‚úÖ Traitement termin√©. ${invoicesGenerated} factures g√©n√©r√©es.`);
  } catch (error) {
    console.error('‚ùå Erreur lors du traitement:', error);
  }
}

/**
 * R√©cup√®re tous les abonnements actifs
 */
async function getActiveSubscriptions() {
  return new Promise((resolve, reject) => {
    const abonnements = [];
    
    abonnementsTable.select({
      filterByFormula: "Statut='Actif'",
      view: "Grid view"
    }).eachPage(
      function page(records, fetchNextPage) {
        records.forEach(record => {
          abonnements.push({
            id: record.id,
            fields: record.fields
          });
        });
        fetchNextPage();
      },
      function done(err) {
        if (err) {
          reject(err);
        } else {
          resolve(abonnements);
        }
      }
    );
  });
}

/**
 * V√©rifie si une facture doit √™tre g√©n√©r√©e aujourd'hui pour cet abonnement
 */
function checkIfInvoiceNeeded(abonnement) {
  // R√©cup√©rer le jour de facturation configur√© (1-31)
  const jourFacturation = abonnement.fields['Jour de facturation'];
  
  if (!jourFacturation) {
    console.warn(`‚ö†Ô∏è Jour de facturation non d√©fini pour l'abonnement ID ${abonnement.id}`);
    return false;
  }

  // Date d'aujourd'hui
  const today = new Date();
  const currentDay = today.getDate();
  
  // V√©rifier si c'est le jour de facturation
  return currentDay === parseInt(jourFacturation);
}

/**
 * R√©cup√®re les services li√©s √† un abonnement
 * Version corrig√©e qui recherche par ID Sellsy
 */
async function getServicesForSubscription(abonnement) {
  // R√©cup√©rer les IDs Sellsy des services li√©s
  const servicesIDs = abonnement.fields['Services li√©s'] || [];
  
  console.log(`üîç Services li√©s pour l'abonnement ID ${abonnement.id}:`, servicesIDs);
  
  if (!servicesIDs.length) {
    console.warn(`‚ö†Ô∏è Aucun ID de service trouv√© pour l'abonnement ID ${abonnement.id}`);
    return [];
  }
  
  // R√©cup√©rer l'ID du client Sellsy
  const idSellsyClient = abonnement.fields['ID_Sellsy_abonn√©'];
  
  if (!idSellsyClient) {
    console.warn(`‚ö†Ô∏è ID Sellsy client non d√©fini pour l'abonnement ID ${abonnement.id}`);
    return [];
  }
  
  // R√©cup√©rer les services correspondant aux IDs Sellsy
  return new Promise((resolve, reject) => {
    const services = [];
    
    // Cr√©er un tableau de promesses pour r√©cup√©rer chaque service individuellement
    const servicePromises = servicesIDs.map(idSellsy => {
      return new Promise((resolveService, rejectService) => {
        serviceTable.select({
          filterByFormula: `AND({ID Sellsy} = '${idSellsy}', {ID_Sellsy_abonn√©} = '${idSellsyClient}', {Actif} = 'Actif', {Cat√©gorie} = 'Abonnement')`,
          maxRecords: 1,
          view: "Grid view"
        }).firstPage((err, records) => {
          if (err) {
            console.error(`‚ùå Erreur lors de la recherche du service ID Sellsy ${idSellsy}:`, err);
            rejectService(err);
            return;
          }
          
          if (records && records.length > 0) {
            console.log(`‚úÖ Service trouv√©: ${records[0].fields['Nom du service']} (ID Sellsy: ${idSellsy})`);
            services.push({
              id: records[0].id,
              fields: records[0].fields
            });
          } else {
            console.warn(`‚ö†Ô∏è Aucun service actif trouv√© pour l'ID Sellsy ${idSellsy}`);
          }
          
          resolveService();
        });
      });
    });
    
    // Attendre que toutes les requ√™tes de service soient termin√©es
    Promise.all(servicePromises)
      .then(() => {
        console.log(`‚úÖ Total de ${services.length} services valides trouv√©s pour l'abonnement ID ${abonnement.id}`);
        resolve(services);
      })
      .catch(error => {
        console.error('‚ùå Erreur lors de la r√©cup√©ration des services:', error);
        reject(error);
      });
  });
}

/**
 * G√©n√®re les factures pour les services et met √† jour les occurrences
 */
async function generateInvoicesForServices(abonnement, services) {
  const idSellsyClient = abonnement.fields['ID_Sellsy_abonn√©'];
  
  if (!idSellsyClient) {
    console.warn(`‚ö†Ô∏è ID Sellsy client non d√©fini pour l'abonnement ID ${abonnement.id}`);
    return;
  }
  
  for (const service of services) {
    const occurrencesRestantes = service.fields['Occurrences restantes'] || 0;
    
    // Ne pas facturer si plus d'occurrences restantes
    if (occurrencesRestantes <= 0) {
      console.log(`‚ÑπÔ∏è Service ID ${service.id}: Pas d'occurrences restantes, aucune facture g√©n√©r√©e`);
      continue;
    }
    
    // G√©n√©rer la facture dans Sellsy
    try {
      // R√©cup√©rer les informations du service
      const serviceInfo = {
        clientId: idSellsyClient,
        serviceId: service.fields['ID Sellsy'],
        serviceName: service.fields['Nom du service'],
        price: service.fields['Prix HT'],
        taxRate: service.fields['Taux TVA'] || 20,
        paymentMethod: 'gocardless'  // Toujours utiliser GoCardless
      };
      
      // G√©n√©rer la facture
      const invoice = await generateInvoice(serviceInfo);
      
      console.log(`‚úÖ Facture g√©n√©r√©e pour le service ${service.fields['Nom du service']} (ID: ${service.id})`);
      
      // Mettre √† jour les occurrences restantes
      await updateServiceOccurrences(service.id);
    } catch (error) {
      console.error(`‚ùå Erreur lors de la g√©n√©ration de la facture pour le service ID ${service.id}:`, error);
    }
  }
}

/**
 * Met √† jour les occurrences apr√®s g√©n√©ration d'une facture
 */
async function updateServiceOccurrences(serviceId) {
  try {
    // R√©cup√©rer le service
    const service = await serviceTable.find(serviceId);
    
    // R√©cup√©rer les valeurs actuelles
    const moisFactures = (service.fields['Mois factur√©s'] || 0) + 1;
    const occurrencesTotales = service.fields['Occurrences totales'] || 0;
    const nouvellesOccurrencesRestantes = Math.max(0, occurrencesTotales - moisFactures);
    
    // Mettre √† jour le service
    await serviceTable.update(serviceId, {
      'Mois factur√©s': moisFactures,
      'Occurrences restantes': nouvellesOccurrencesRestantes
    });
    
    console.log(`‚úÖ Service ID ${serviceId}: ${nouvellesOccurrencesRestantes}/${occurrencesTotales} occurrences restantes`);
  } catch (error) {
    console.error(`‚ùå Erreur lors de la mise √† jour des occurrences pour le service ID ${serviceId}:`, error);
  }
}

// Ex√©cution du programme principal
main();
